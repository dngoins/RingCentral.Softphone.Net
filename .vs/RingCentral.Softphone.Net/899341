{"version":1,"Request":{"Prompt":"how do I send RTPPacket.Payload to Speech API","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B=\r\n                                (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                                {\r\n                                    //Console.WriteLine(\u0022OnRtpPacketReceived\u0022);\r\n\r\n                                    //Let\u0027s send packets every 8000 samples (100ms) \r\n                                    audioBuffer.Add(rtpPacket.Payload);\r\n                                    var audioBufferLength = rtpPacket.Payload.Length;\r\n                                    if (audioBuffer.Count == 100)\r\n                                    {\r\n                                        var audioBufferToSend = new byte[audioBufferLength * 100];\r\n                                        for (var i = 0; i \u003C 100; i\u002B\u002B)\r\n                                        {\r\n                                            Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend,\r\n                                                                                               i * audioBufferLength, audioBufferLength);\r\n                                        }\r\n\r\n                                        RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * 100).GetAwaiter().GetResult();   \r\n                                        audioBuffer.Clear();\r\n                                    }\r\n\r\n                                };\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":8120,"Start":620,"End":10422}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"ff2e70ba-9d82-4eda-ade5-f4522db42194"}}},"Response":{"Content":"To send \u0060RTPPacket.Payload\u0060 to the Speech API, you can use the \u0060SpeechConfig\u0060, \u0060AudioConfig\u0060, and \u0060SpeechRecognizer\u0060 classes in C#.\r\n\r\nFirst, create a new instance of \u0060SpeechConfig\u0060 which you can use to configure the speech recognition service by defining parameters such as \u0060SubscriptionKey\u0060, \u0060Region\u0060, and \u0060Language\u0060. \r\n\r\nThen, create a new instance of \u0060AudioConfig\u0060 with the \u0060RTPPacket.Payload\u0060 data. This can be achieved by using \u0060MemoryStream\u0060 and \u0060BinaryReader\u0060 classes to convert \u0060RTPPacket.Payload\u0060 into audio data that can be understood by the Speech API.\r\n\r\nNext, create a new instance of \u0060SpeechRecognizer\u0060 with the \u0060SpeechConfig\u0060 and \u0060AudioConfig\u0060. This class will allow you to start the recognition process and retrieve the recognized text or result.\r\n\r\nHere\u0027s an example code snippet in C#:\r\n\r\n\u0060\u0060\u0060csharp\r\nSpeechConfig speechConfig = SpeechConfig.FromSubscription(\u0022YourSubscriptionKey\u0022, \u0022YourServiceRegion\u0022);\r\nMemoryStream audioStream = new MemoryStream(rtpPacket.Payload);\r\nBinaryReader reader = new BinaryReader(audioStream);\r\nAudioConfig audioConfig = AudioConfig.FromStreamInput(reader.BaseStream);\r\nSpeechRecognizer recognizer = new SpeechRecognizer(speechConfig, audioConfig);\r\n\r\nvar result = await recognizer.RecognizeOnceAsync();\r\n\r\nConsole.WriteLine($\u0022Recognized text: {result.Text}\u0022);\r\n\u0060\u0060\u0060\r\n\r\nIt is important to note that this example code assumes you have valid subscription keys and region information. You can replace \u0022YourSubscriptionKey\u0022 and \u0022YourServiceRegion\u0022 with your own information. Also, make sure to properly dispose the \u0060StreamReader\u0060, \u0060MemoryStream\u0060, and \u0060SpeechRecognizer\u0060 objects to avoid memory leaks.","Type":0,"Status":1,"FollowUpPrompts":["Can I use a different audio format with the Speech API?","What other Speech API features are there?"]},"SelectedFunctionName":"Answer","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"how do I get 16000 samples per second from the rtpPacket","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            var packets = 5;\r\n                            var framesize = 100;\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B=\r\n                                (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                                {\r\n                                    //drop 3 packets\r\n                                    packets--;\r\n                                    if (packets \u003E 0)\r\n                                    {\r\n                                        return;\r\n                                    }\r\n                                    packets = 0;\r\n                                    //Console.WriteLine(\u0022OnRtpPacketReceived\u0022);\r\n\r\n                                    //Let\u0027s send packets every 8000 samples (100ms) \r\n                                    audioBuffer.Add(rtpPacket.Payload);\r\n                                    var audioBufferLength = rtpPacket.Payload.Length;\r\n                                    System.Diagnostics.Debug.WriteLine($\u0022audioBufferLength: {audioBufferLength}\u0022);\r\n\r\n                                    if (audioBuffer.Count == framesize)\r\n                                    {\r\n                                        var audioBufferToSend = new byte[audioBufferLength * framesize];\r\n                                        for (var i = 0; i \u003C framesize; i\u002B\u002B)\r\n                                        {\r\n                                            Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend,\r\n                                                                                               i * audioBufferLength, audioBufferLength);\r\n                                        }\r\n\r\n                                        RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * framesize).GetAwaiter().GetResult();   \r\n                                        audioBuffer.Clear();\r\n                                    }\r\n\r\n                                    \r\n                                };\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":8829,"Start":620,"End":11033}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"4470c8e5-0cc5-46f4-af6a-ca0f0b02ab39"}}},"Response":{"Content":"To get 16000 samples per second from the \u0060rtpPacket\u0060, you will need to modify the \u0060OnRtpPacketReceived\u0060 event in the \u0060RTPSession\u0060 class.\r\n\r\nIn the \u0060OnRtpPacketReceived\u0060 event, you can calculate the sample rate using the formula \u0060sampleRate = clockFrequency / clockRateMultiplier\u0060 where \u0060clockFrequency\u0060 is the \u0060RTPPacket.ClockRate\u0060 and \u0060clockRateMultiplier\u0060 is a constant value usually set to 2. \r\n\r\nHere is an example of how to modify the \u0060OnRtpPacketReceived\u0060 event:\r\n\r\n\u0060\u0060\u0060csharp\r\nrtpSession.OnRtpPacketReceived \u002B= (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n{\r\n    //drop 3 packets\r\n    packets--;\r\n    if (packets \u003E 0)\r\n    {\r\n        return;\r\n    }\r\n    packets = 0;\r\n\r\n    // calculate sample rate\r\n    int clockFrequency = rtpPacket.ClockRate;\r\n    int clockRateMultiplier = 2;\r\n    int sampleRate = clockFrequency / clockRateMultiplier;\r\n\r\n    // Let\u0027s send packets every 16000 samples (1 second) \r\n    audioBuffer.Add(rtpPacket.Payload);\r\n    var audioBufferLength = rtpPacket.Payload.Length;\r\n    System.Diagnostics.Debug.WriteLine($\u0022audioBufferLength: {audioBufferLength}\u0022);\r\n\r\n    if (audioBufferLength == sampleRate * 2) // 2 bytes per sample\r\n    {\r\n        var audioBufferToSend = new byte[audioBufferLength * framesize];\r\n        for (var i = 0; i \u003C framesize; i\u002B\u002B)\r\n        {\r\n            Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend, i * audioBufferLength, audioBufferLength);\r\n        }\r\n\r\n        RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * framesize).GetAwaiter().GetResult();   \r\n        audioBuffer.Clear();\r\n    }\r\n};\r\n\u0060\u0060\u0060\r\n\r\nThis code will now send packets every second (16000 samples per second) instead of every 100ms (8000 samples per second) as before.\r\n\r\nPlease note that the \u0060RTPPacket.ClockRate\u0060 value may vary depending on the audio format used. Additionally, this modification assumes that \u0060SDPWellKnownMediaFormatsEnum.PCMU\u0060 is used for the \u0060MediaStreamTrack\u0060, as stated in the code above.","Type":0,"Status":1,"FollowUpPrompts":["What is \u0060ClockRateMultiplier\u0060?","How do I determine the \u0060ClockFrequency\u0060 value for a given audio format?"]},"SelectedFunctionName":"Explain","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"How do I get the clockrate from an rtpPacket","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            var packets = 5;\r\n                            var framesize = 100;\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B= (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                            {\r\n                                //drop 3 packets\r\n                                packets--;\r\n                                if (packets \u003E 0)\r\n                                {\r\n                                    return;\r\n                                }\r\n                                packets = 0;\r\n\r\n                                // calculate sample rate\r\n                                int clockFrequency = rtpPacket.Header.ClockRate;\r\n                                int clockRateMultiplier = 2;\r\n                                int sampleRate = clockFrequency / clockRateMultiplier;\r\n\r\n                                // Let\u0027s send packets every 16000 samples (1 second) \r\n                                audioBuffer.Add(rtpPacket.Payload);\r\n                                var audioBufferLength = rtpPacket.Payload.Length;\r\n                                System.Diagnostics.Debug.WriteLine($\u0022audioBufferLength: {audioBufferLength}\u0022);\r\n\r\n                                if (audioBufferLength == sampleRate * 2) // 2 bytes per sample\r\n                                {\r\n                                    var audioBufferToSend = new byte[audioBufferLength * framesize];\r\n                                    for (var i = 0; i \u003C framesize; i\u002B\u002B)\r\n                                    {\r\n                                        Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend, i * audioBufferLength, audioBufferLength);\r\n                                    }\r\n\r\n                                    RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * framesize).GetAwaiter().GetResult();\r\n                                    audioBuffer.Clear();\r\n                                }\r\n                            };\r\n\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":8449,"Start":620,"End":11014}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"9b03dc2c-2530-4b52-800e-545df388a146"}}},"Response":{"Content":"To get the \u0060ClockRate\u0060 value from an \u0060RTPPacket\u0060 in C#, you can simply access the \u0060ClockRate\u0060 property of the \u0060RTPPacket\u0060 object. \r\n\r\nHere\u0027s an example:\r\n\r\n\u0060\u0060\u0060csharp\r\nint clockRate = rtpPacket.ClockRate;\r\n\u0060\u0060\u0060\r\n\r\nThis will return an integer representing the clock rate of the \u0060RTPPacket\u0060. You can then use this value in your calculations, such as to calculate the sample rate as explained in the previous answer.\r\n\r\nIt\u0027s important to note that \u0060ClockRate\u0060 value can vary depending on the specific audio format used in the \u0060RTPPacket\u0060. Therefore, it\u0027s important to know the audio format and configure your code accordingly.","Type":0,"Status":1,"FollowUpPrompts":["How can I check the audio format used in an RTPPacket?","Can ClockRate value change during a single RTPSession?"]},"SelectedFunctionName":"Answer","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"How do I determine the \u0060ClockFrequency\u0060 value for a given audio format?","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            var packets = 5;\r\n                            var framesize = 100;\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B= (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                            {\r\n                                //drop 3 packets\r\n                                packets--;\r\n                                if (packets \u003E 0)\r\n                                {\r\n                                    return;\r\n                                }\r\n                                packets = 0;\r\n\r\n                                rtpSession.\r\n                                // calculate sample rate\r\n                                int clockFrequency = rtpPacket.clockRate;\r\n                                int clockRateMultiplier = 2;\r\n                                int sampleRate = clockFrequency / clockRateMultiplier;\r\n\r\n                                // Let\u0027s send packets every 16000 samples (1 second) \r\n                                audioBuffer.Add(rtpPacket.Payload);\r\n                                var audioBufferLength = rtpPacket.Payload.Length;\r\n                                System.Diagnostics.Debug.WriteLine($\u0022audioBufferLength: {audioBufferLength}\u0022);\r\n\r\n                                if (audioBufferLength == sampleRate * 2) // 2 bytes per sample\r\n                                {\r\n                                    var audioBufferToSend = new byte[audioBufferLength * framesize];\r\n                                    for (var i = 0; i \u003C framesize; i\u002B\u002B)\r\n                                    {\r\n                                        Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend, i * audioBufferLength, audioBufferLength);\r\n                                    }\r\n\r\n                                    RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * framesize).GetAwaiter().GetResult();\r\n                                    audioBuffer.Clear();\r\n                                }\r\n                            };\r\n\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":8364,"Start":8364,"End":8364}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"ace2196e-4747-4faf-be8c-4e8607391977"}}},"Response":{"Content":"To determine the \u0060ClockFrequency\u0060 value for a given audio format, you will need to refer to the documentation or specification of that particular audio format. \r\n\r\nFor example, the \u0060ClockFrequency\u0060 value for the \u0060PCMA\u0060 and \u0060PCMU\u0060 audio formats used in VoIP systems is 8000 Hz. The \u0060ClockFrequency\u0060 value for the \u0060opus\u0060 audio format, which is commonly used in web browsers, is 48000 Hz. \r\n\r\nHowever, different audio formats may have different \u0060ClockFrequency\u0060 values. Therefore, it is important to check the corresponding audio format documentation or specification to determine the \u0060ClockFrequency\u0060 value.","Type":0,"Status":1,"FollowUpPrompts":["Explain how to determine the audio format","What other audio formats have different clock frequencies?"]},"SelectedFunctionName":"Answer","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"what is the byte size for the rtpPacket.Payload.Length","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            var packets = 5;\r\n                            var framesize = 100;\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B= (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                            {\r\n                                //drop 3 packets\r\n                                packets--;\r\n                                if (packets \u003E 0)\r\n                                {\r\n                                    return;\r\n                                }\r\n                                packets = 0;\r\n\r\n                               \r\n                                // calculate sample rate\r\n                                int clockFrequency = 8000;\r\n                                int clockRateMultiplier = 2;\r\n                                int sampleRate = clockFrequency / clockRateMultiplier;\r\n\r\n                                // Let\u0027s send packets every 16000 samples (1 second) \r\n                                audioBuffer.Add(rtpPacket.Payload);\r\n                                var audioBufferLength = rtpPacket.Payload.Length;\r\n                                System.Diagnostics.Debug.WriteLine($\u0022audioBufferLength: {audioBufferLength}\u0022);\r\n\r\n                                if (audioBufferLength == sampleRate * 2) // 2 bytes per sample\r\n                                {\r\n                                    var audioBufferToSend = new byte[audioBufferLength * framesize];\r\n                                    for (var i = 0; i \u003C framesize; i\u002B\u002B)\r\n                                    {\r\n                                        Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend, i * audioBufferLength, audioBufferLength);\r\n                                    }\r\n\r\n                                    RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * framesize).GetAwaiter().GetResult();\r\n                                    audioBuffer.Clear();\r\n                                }\r\n                            };\r\n\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":7716,"Start":620,"End":11025}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"46106268-ff71-4c19-9e62-22de19c79fc5"}}},"Response":{"Content":"The \u0060rtpPacket.Payload.Length\u0060 property returns an integer representing the size of the \u0060Payload\u0060 property of the \u0060rtpPacket\u0060 object, in bytes. This size can vary depending on the specific audio format used.\r\n\r\nHere\u0027s an example of how to get the byte size of the \u0060Payload\u0060 using C#:\r\n\r\n\u0060\u0060\u0060csharp\r\nint payloadSize = rtpPacket.Payload.Length;\r\n\u0060\u0060\u0060\r\n\r\nThis code will return an integer value representing the size of the \u0060rtpPacket.Payload\u0060 in bytes.\r\n\r\nPossible ways to improve the code with respect to readability and performance include:\r\n\r\n- Using \u0060uint\u0060 instead of \u0060int\u0060 for the \u0060payloadSize\u0060 variable to accommodate larger packet sizes.\r\n- Using a constant variable to store the byte size of the payload if it is always the same instead of calculating it every time.","Type":0,"Status":1,"FollowUpPrompts":["How can I determine the audio format used?","Can the byte size change during transmission and reception?"]},"SelectedFunctionName":"Answer","LoggedSkillInvocations":null}
{"version":1,"Request":{"Prompt":"How to convert the audioBufferToSend to little-endian","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            var packets = 3;\r\n                            var framesize = 100;\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B=\r\n                                (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                                {\r\n                                    //drop 3 packets\r\n                                    packets--;\r\n                                    if (packets \u003E 0)\r\n                                    {\r\n                                        return;\r\n                                    }\r\n                                    packets = 0;\r\n                                    //Console.WriteLine(\u0022OnRtpPacketReceived\u0022);\r\n\r\n                                    //Let\u0027s send packets every 8000 samples (100ms) \r\n                                    audioBuffer.Add(rtpPacket.Payload);\r\n                                    var audioBufferLength = rtpPacket.Payload.Length;\r\n                                    System.Diagnostics.Debug.WriteLine($\u0022audioBufferLength: {audioBufferLength}\u0022);\r\n\r\n                                    if (audioBuffer.Count == framesize)\r\n                                    {\r\n                                        var audioBufferToSend = new byte[audioBufferLength * framesize];\r\n                                        for (var i = 0; i \u003C framesize; i\u002B\u002B)\r\n                                        {\r\n                                            Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend,\r\n                                                                                               i * audioBufferLength, audioBufferLength);\r\n                                        }\r\n\r\n                                        RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * framesize).GetAwaiter().GetResult();   \r\n                                        audioBuffer.Clear();\r\n                                    }\r\n\r\n                                    \r\n                                };\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":8103,"Start":620,"End":11033}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"8eeb8e6d-ea9a-4943-8409-f12b631bb9b8"}}},"Response":{"Content":"\u0060\u0060\u0060C#\n// Create a byte array to store the little-endian converted audio buffer\nbyte[] littleEndianBuffer = new byte[audioBufferToSend.Length];\n\n// Convert each pair of bytes in the audio buffer to little-endian and store in the new buffer\nfor (int i = 0; i \u003C audioBufferToSend.Length; i\u002B=2)\n{\n    littleEndianBuffer[i] = audioBufferToSend[i \u002B 1];\n    littleEndianBuffer[i \u002B 1] = audioBufferToSend[i];\n}\n\n// Use the little-endian converted buffer for recognition\nRecognitionWithPushAudioStreamAsync(littleEndianBuffer, littleEndianBuffer.Length).GetAwaiter().GetResult();\n\u0060\u0060\u0060","Type":1,"Status":1,"FollowUpPrompts":null},"SelectedFunctionName":"Modify","LoggedSkillInvocations":null}
