{"version":1,"Request":{"Prompt":"how do I send RTPPacket.Payload to Speech API","Context":{"VisibleDocuments":[{"Content":"using System;\r\nusing System.Collections.Generic;\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Text.RegularExpressions;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing dotenv.net;\r\nusing Nager.TcpClient;\r\nusing Org.BouncyCastle.Asn1.X509;\r\nusing RingCentral.Softphone.Net;\r\nusing SIPSorcery.Net;\r\nusing SIPSorcery.SIP.App;\r\nusing SIPSorceryMedia.Abstractions;\r\n\r\nusing Microsoft.CognitiveServices.Speech;\r\nusing Microsoft.CognitiveServices.Speech.Audio;\r\nusing System.IO;\r\n\r\nnamespace RingCentral.Softphone.Demo\r\n{\r\n    class Program\r\n    {\r\n        //static SpeechConfig config = null;\r\n        \r\n        static void Main(string[] args)\r\n        {\r\n            DotEnv.Load(new DotEnvOptions().WithOverwriteExistingVars());\r\n            \r\n            Task.Run(async () =\u003E\r\n            {\r\n                var sipInfo = new SipInfoResponse();\r\n                sipInfo.domain = Environment.GetEnvironmentVariable(\u0022SIP_INFO_DOMAIN\u0022);\r\n                sipInfo.password = Environment.GetEnvironmentVariable(\u0022SIP_INFO_PASSWORD\u0022);\r\n                sipInfo.outboundProxy = Environment.GetEnvironmentVariable(\u0022SIP_INFO_OUTBOUND_PROXY\u0022);\r\n                sipInfo.authorizationId = Environment.GetEnvironmentVariable(\u0022SIP_INFO_AUTHORIZATION_ID\u0022);\r\n                sipInfo.username = Environment.GetEnvironmentVariable(\u0022SIP_INFO_USERNAME\u0022);\r\n\r\n               // Program.config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n                var client = new TcpClient();\r\n                var tokens = sipInfo.outboundProxy!.Split(\u0022:\u0022);\r\n                await client.ConnectAsync(tokens[0], int.Parse(tokens[1]));\r\n\r\n                var userAgent = \u0022RingCentral.Softphone.Net\u0022;\r\n                var fakeDomain = $\u0022{Guid.NewGuid().ToString()}.invalid\u0022;\r\n                var fakeEmail = $\u0022{Guid.NewGuid().ToString()}@{fakeDomain}\u0022;\r\n\r\n                var registrationMessage = new SipMessage($\u0022REGISTER sip:{sipInfo.domain} SIP/2.0\u0022,\r\n                    new Dictionary\u003Cstring, string\u003E\r\n                    {\r\n                        {\u0022Call-ID\u0022, Guid.NewGuid().ToString()},\r\n                        {\u0022User-Agent\u0022, userAgent},\r\n                        {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E;expires=600\u0022},\r\n                        {\u0022Via\u0022, $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022From\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E;tag={Guid.NewGuid().ToString()}\u0022},\r\n                        {\u0022To\u0022, $\u0022\u003Csip:{sipInfo.username}@{sipInfo.domain}\u003E\u0022},\r\n                        {\u0022CSeq\u0022, \u00228082 REGISTER\u0022},\r\n                        {\u0022Content-Length\u0022, \u00220\u0022},\r\n                        {\u0022Max-Forwards\u0022, \u002270\u0022}\r\n                    }, \u0022\u0022);\r\n\r\n                var cachedMessages = \u0022\u0022;\r\n\r\n                // receive message\r\n                void OnDataReceived(byte[] receivedData)\r\n                {\r\n                    var data = Encoding.UTF8.GetString(receivedData);\r\n                    Console.WriteLine(\u0022Receiving...\\n\u0022 \u002B data);\r\n                    cachedMessages \u002B= data;\r\n                }\r\n\r\n                client.DataReceived \u002B= OnDataReceived;\r\n\r\n                // send message\r\n                async void SendMessage(SipMessage sipMessage)\r\n                {\r\n                    var message = sipMessage.ToMessage();\r\n                    Console.WriteLine(\u0022Sending...\\n\u0022 \u002B message);\r\n                    var bytes = Encoding.UTF8.GetBytes(message);\r\n                    await client.SendAsync(bytes);\r\n                }\r\n\r\n                // send first registration message\r\n                SendMessage(registrationMessage);\r\n\r\n                RTPSession latestSession = null;\r\n\r\n                // wait for server messages forever\r\n                while (true)\r\n                {\r\n                    await Task.Delay(100);\r\n                    if (cachedMessages.Length \u003E 0)\r\n                    {\r\n                        // just in case, sometimes we only receive half a message, wait for the other half\r\n                        await Task.Delay(100);\r\n\r\n                        var tempMessages = cachedMessages.Split(\u0022\\r\\n\\r\\nSIP/2.0 \u0022);\r\n                        // sometimes we receive two messages in one data\r\n                        if (tempMessages.Length \u003E 1)\r\n                        {\r\n                            // in this case, we only need the second one\r\n                            cachedMessages = \u0022SIP/2.0 \u0022 \u002B tempMessages[1];\r\n                        }\r\n\r\n                        var sipMessage = SipMessage.FromMessage(cachedMessages);\r\n\r\n                        // reset variables\r\n                        cachedMessages = \u0022\u0022;\r\n\r\n                        // the message after we reply to INVITE\r\n                        if (sipMessage.Subject.StartsWith(\u0022ACK sip:\u0022))\r\n                        {\r\n                            // The purpose of sending a DTMF tone is if our SDP had a private IP address then the server needs to get at least\r\n                            // one RTP packet to know where to send.\r\n                            await latestSession!.SendDtmf(0, CancellationToken.None);\r\n                        }\r\n\r\n                        // authorize failed with nonce in header\r\n                        if (sipMessage.Subject.StartsWith(\u0022SIP/2.0 401 Unauthorized\u0022))\r\n                        {\r\n                            var nonceMessage = sipMessage;\r\n                            var wwwAuth = \u0022\u0022;\r\n                            if (nonceMessage.Headers.ContainsKey(\u0022WWW-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022WWW-Authenticate\u0022];\r\n                            }\r\n                            else if (nonceMessage.Headers.ContainsKey(\u0022Www-Authenticate\u0022))\r\n                            {\r\n                                wwwAuth = nonceMessage.Headers[\u0022Www-Authenticate\u0022];\r\n                            }\r\n\r\n                            var regex = new Regex(\u0022, nonce=\\\u0022(.\u002B?)\\\u0022\u0022);\r\n                            var match = regex.Match(wwwAuth);\r\n                            var nonce = match.Groups[1].Value;\r\n                            var auth = Net.Utils.GenerateAuthorization(sipInfo, \u0022REGISTER\u0022, nonce);\r\n                            registrationMessage.Headers[\u0022Authorization\u0022] = auth;\r\n                            registrationMessage.Headers[\u0022CSeq\u0022] = \u00228083 REGISTER\u0022;\r\n                            registrationMessage.Headers[\u0022Via\u0022] =\r\n                                $\u0022SIP/2.0/TCP {fakeDomain};branch=z9hG4bK{Guid.NewGuid().ToString()}\u0022;\r\n                            SendMessage(registrationMessage);\r\n                        }\r\n\r\n                        // whenever there is an inbound call\r\n                        if (sipMessage.Subject.StartsWith(\u0022INVITE sip:\u0022))\r\n                        {\r\n                            var rtpSession = new RTPSession(false, false, false);\r\n                            latestSession = rtpSession;\r\n                            var inviteSipMessage = sipMessage;\r\n                            MediaStreamTrack audioTrack = new MediaStreamTrack(new List\u003CAudioFormat\u003E\r\n                                {new AudioFormat(SDPWellKnownMediaFormatsEnum.PCMU)});\r\n                            rtpSession.addTrack(audioTrack);\r\n                            var result =\r\n                                rtpSession.SetRemoteDescription(SdpType.offer,\r\n                                    SDP.ParseSDPDescription(inviteSipMessage.Body));\r\n                            Console.WriteLine(result);\r\n                            var answer = rtpSession.CreateAnswer(null);\r\n                            List\u003Cbyte[]\u003E audioBuffer = new List\u003Cbyte[]\u003E();\r\n\r\n                            rtpSession.OnRtpPacketReceived \u002B=\r\n                                (IPEndPoint remoteEndPoint, SDPMediaTypesEnum mediaType, RTPPacket rtpPacket) =\u003E\r\n                                {\r\n                                    //Console.WriteLine(\u0022OnRtpPacketReceived\u0022);\r\n\r\n                                    //Let\u0027s send packets every 8000 samples (100ms) \r\n                                    audioBuffer.Add(rtpPacket.Payload);\r\n                                    var audioBufferLength = rtpPacket.Payload.Length;\r\n                                    if (audioBuffer.Count == 100)\r\n                                    {\r\n                                        var audioBufferToSend = new byte[audioBufferLength * 100];\r\n                                        for (var i = 0; i \u003C 100; i\u002B\u002B)\r\n                                        {\r\n                                            Buffer.BlockCopy(audioBuffer[i], 0, audioBufferToSend,\r\n                                                                                               i * audioBufferLength, audioBufferLength);\r\n                                        }\r\n\r\n                                        RecognitionWithPushAudioStreamAsync(audioBufferToSend, audioBufferLength * 100).GetAwaiter().GetResult();   \r\n                                        audioBuffer.Clear();\r\n                                    }\r\n\r\n                                };\r\n\r\n                            sipMessage =\r\n                                new SipMessage(\u0022SIP/2.0 200 OK\u0022, new Dictionary\u003Cstring, string\u003E\r\n                                {\r\n                                    {\u0022Contact\u0022, $\u0022\u003Csip:{fakeEmail};transport=tcp\u003E\u0022},\r\n                                    {\u0022Content-Type\u0022, \u0022application/sdp\u0022},\r\n                                    {\u0022Content-Length\u0022, answer.ToString().Length.ToString()},\r\n                                    {\u0022User-Agent\u0022, \u0022RingCentral.Softphone.Net\u0022},\r\n                                    {\u0022Via\u0022, inviteSipMessage.Headers[\u0022Via\u0022]},\r\n                                    {\u0022From\u0022, inviteSipMessage.Headers[\u0022From\u0022]},\r\n                                    {\u0022To\u0022, $\u0022{inviteSipMessage.Headers[\u0022To\u0022]};tag={Guid.NewGuid().ToString()}\u0022},\r\n                                    {\u0022CSeq\u0022, inviteSipMessage.Headers[\u0022CSeq\u0022]},\r\n                                    {\u0022Supported\u0022, \u0022outbound\u0022},\r\n                                    {\u0022Call-Id\u0022, inviteSipMessage.Headers[\u0022Call-Id\u0022]}\r\n                                }, answer.ToString());\r\n                            SendMessage(sipMessage);\r\n                        }\r\n                    }\r\n                }\r\n            }).GetAwaiter().GetResult();\r\n        }\r\n\r\n        public static async Task RecognitionWithPushAudioStreamAsync(byte[] audioBuffer, int audioBufferLength)\r\n        {\r\n           var config = SpeechConfig.FromSubscription(Environment.GetEnvironmentVariable(\u0022SPEECH_SUB_KEY\u0022), Environment.GetEnvironmentVariable(\u0022SPEECH_REGION\u0022));\r\n\r\n            var stopRecognition = new TaskCompletionSource\u003Cint\u003E(TaskCreationOptions.RunContinuationsAsynchronously);\r\n\r\n            // Create a push stream\r\n            using (var pushStream = AudioInputStream.CreatePushStream())\r\n            {\r\n                using (var audioInput = AudioConfig.FromStreamInput(pushStream))\r\n                {\r\n                    // Creates a speech recognizer using audio stream input.\r\n                    using (var recognizer = new SpeechRecognizer(config, audioInput))\r\n                    {\r\n                        // Subscribes to events.\r\n                        recognizer.Recognizing \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022RECOGNIZING: Text={e.Result.Text}\u0022);\r\n                        };\r\n\r\n                        recognizer.Recognized \u002B= (s, e) =\u003E\r\n                        {\r\n                            if (e.Result.Reason == ResultReason.RecognizedSpeech)\r\n                            {\r\n                                Console.WriteLine($\u0022RECOGNIZED: Text={e.Result.Text}\u0022);\r\n                            }\r\n                            else if (e.Result.Reason == ResultReason.NoMatch)\r\n                            {\r\n                                Console.WriteLine($\u0022NOMATCH: Speech could not be recognized.\u0022);\r\n                            }\r\n                        };\r\n\r\n                        recognizer.Canceled \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine($\u0022CANCELED: Reason={e.Reason}\u0022);\r\n\r\n                            if (e.Reason == CancellationReason.Error)\r\n                            {\r\n                                Console.WriteLine($\u0022CANCELED: ErrorCode={e.ErrorCode}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: ErrorDetails={e.ErrorDetails}\u0022);\r\n                                Console.WriteLine($\u0022CANCELED: Did you update the subscription info?\u0022);\r\n                            }\r\n\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        recognizer.SessionStarted \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession started event.\u0022);\r\n                        };\r\n\r\n                        recognizer.SessionStopped \u002B= (s, e) =\u003E\r\n                        {\r\n                            Console.WriteLine(\u0022\\nSession stopped event.\u0022);\r\n                            Console.WriteLine(\u0022\\nStop recognition.\u0022);\r\n                            stopRecognition.TrySetResult(0);\r\n                        };\r\n\r\n                        // Starts continuous recognition. Uses StopContinuousRecognitionAsync() to stop recognition.\r\n                        await recognizer.StartContinuousRecognitionAsync().ConfigureAwait(false);\r\n\r\n                        // open and read the wave file and push the buffers into the recognizer\r\n                        using (BinaryAudioStreamReader reader = new BinaryAudioStreamReader(new MemoryStream(audioBuffer, 0, audioBufferLength)))\r\n                        {\r\n                            byte[] buffer = new byte[1000];\r\n                            while (true)\r\n                            {\r\n                                var readSamples = reader.Read(buffer, (uint)buffer.Length);\r\n                                if (readSamples == 0)\r\n                                {\r\n                                    break;\r\n                                }\r\n                                pushStream.Write(buffer, readSamples);\r\n                            }\r\n                        }\r\n                        pushStream.Close();\r\n\r\n                        // Waits for completion.\r\n                        // Use Task.WaitAny to keep the task rooted.\r\n                        Task.WaitAny(new[] { stopRecognition.Task });\r\n\r\n                        // Stops recognition.\r\n                        await recognizer.StopContinuousRecognitionAsync().ConfigureAwait(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","Selections":[{"Caret":8120,"Start":620,"End":10422}],"FilePath":"C:\\Users\\dngoi\\source\\repos\\github\\dngoins\\rc\\RingCentral.Softphone.Demo\\Program.cs","Language":"C#"}],"PreSelectedSkill":null,"CorrelationId":{"Guid":"ff2e70ba-9d82-4eda-ade5-f4522db42194"}}},"Response":{"Content":"To send \u0060RTPPacket.Payload\u0060 to the Speech API, you can use the \u0060SpeechConfig\u0060, \u0060AudioConfig\u0060, and \u0060SpeechRecognizer\u0060 classes in C#.\r\n\r\nFirst, create a new instance of \u0060SpeechConfig\u0060 which you can use to configure the speech recognition service by defining parameters such as \u0060SubscriptionKey\u0060, \u0060Region\u0060, and \u0060Language\u0060. \r\n\r\nThen, create a new instance of \u0060AudioConfig\u0060 with the \u0060RTPPacket.Payload\u0060 data. This can be achieved by using \u0060MemoryStream\u0060 and \u0060BinaryReader\u0060 classes to convert \u0060RTPPacket.Payload\u0060 into audio data that can be understood by the Speech API.\r\n\r\nNext, create a new instance of \u0060SpeechRecognizer\u0060 with the \u0060SpeechConfig\u0060 and \u0060AudioConfig\u0060. This class will allow you to start the recognition process and retrieve the recognized text or result.\r\n\r\nHere\u0027s an example code snippet in C#:\r\n\r\n\u0060\u0060\u0060csharp\r\nSpeechConfig speechConfig = SpeechConfig.FromSubscription(\u0022YourSubscriptionKey\u0022, \u0022YourServiceRegion\u0022);\r\nMemoryStream audioStream = new MemoryStream(rtpPacket.Payload);\r\nBinaryReader reader = new BinaryReader(audioStream);\r\nAudioConfig audioConfig = AudioConfig.FromStreamInput(reader.BaseStream);\r\nSpeechRecognizer recognizer = new SpeechRecognizer(speechConfig, audioConfig);\r\n\r\nvar result = await recognizer.RecognizeOnceAsync();\r\n\r\nConsole.WriteLine($\u0022Recognized text: {result.Text}\u0022);\r\n\u0060\u0060\u0060\r\n\r\nIt is important to note that this example code assumes you have valid subscription keys and region information. You can replace \u0022YourSubscriptionKey\u0022 and \u0022YourServiceRegion\u0022 with your own information. Also, make sure to properly dispose the \u0060StreamReader\u0060, \u0060MemoryStream\u0060, and \u0060SpeechRecognizer\u0060 objects to avoid memory leaks.","Type":0,"Status":1,"FollowUpPrompts":["Can I use a different audio format with the Speech API?","What other Speech API features are there?"]},"SelectedFunctionName":"Answer","LoggedSkillInvocations":null}
